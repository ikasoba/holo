# 式の脱糖
一部の式を複数の文に分解します。

- C言語で文として扱われる構文
  式の途中に出てくるif式やswitch式などをC言語レベルのswitch文、if文などへ変換しやすいように変形します。

検討点: 評価順を維持するためには、式全体を文の列に分解しなければならない？

## コンテナ
直下に文および式を含むことのできるノード。
- FunctionDecl
- While
- Block

## 対象の式
これらの構文はC言語レベルでは文として扱われるため、この構文が含まれる部分は文として分解しなければなりません。
- ブロック式
- if式
- switch式

## アルゴリズム
式の変形
1. コンテナに変数(a)を追加します。
2. 対象の式(t)を先に評価するために、変数aへ式tを代入する代入文を追加します。
3. 元の式の中で式tがあった部分を変数aの参照ノードで置き換えます。

- 内側で見つかったコンテナから順に処理
- バイナリノードは左から右の順に処理

### 変形イメージ
```
fn f() {
  var x = {
    var c = {
      var a = 1 + 2;
      a
    } + {
      var b = 3 * 4;
      b
    } * 5;
    c
  };
}
```
↓
```c
void f() {
  int x;
  {
    int s0, s1, s2;
    int c;
    {
      int a;
      a = 1 + 2;
      s0 = a;
    };
    {
      int b;
      b = 3 * 4;
      s1 = b;
    };
    s2 = s0 + s1 * 5;
    c = s2;
    x = c;
  };
}
```

# 基本的な変形
## block
```
var x = { var a = 1; a };
```
↓
```c
int x;
{
  int a = 1;
  x = a;
}
```

## if
```
var x = if (a) { 1 } else { 2 };
```
↓
```c
int x;
if (a) {
  x = 1;
} else {
  x = 2;
}
```

## switch
```
var x =
  switch (a) {
    case 0 || 2 {
      0
    }
    case 1 || 3 {
      1
    }
    default {
      2
    }
  };
```
↓
```c
int x;
switch (a) {
  case 0:
  case 2: {
    x = 0;
    break;
  }
  case 1:
  case 3: {
    x = 1;
    break;
  }
  default: {
    x = 2;
    break;
  }
}
```
